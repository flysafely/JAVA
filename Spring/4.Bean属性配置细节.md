### 手动装配bean
  + 通过成员变量的setter方法来配置
    + 通过bean中的property标签
      > property标签中没有type属性
      ```xml
      <bean id="sub" class="com.bean.attribute.world" p:string="subworld"></bean>
      <bean id="helloworld" class="com.bean.attribute.helloworld">
          <property name="string" value="helloworld"></property>
          <property name="time" value="20191202"></property>
          <!-- name代表的是类中成员变量名称，ref代表该xml中bean对象的id名称 -->
          <property name="subworld" ref="sub"></property>
      </bean>
      ```
    + 通过bean中p:<sub>属性名</sub>的方式给bean配置属性值
      > 需要在Namespaces中勾选p
      ```xml
      <bean id="helloworld" class="com.bean.attribute.helloworld" p:string="helloworld" p:time="20191202"></bean>
      ```
  + 通过类构造函数constructor方法来配置
    > constructor-arg标签中有type属性，可以通过type来指定value中的数据应该转换成什么类型
      ```xml
      <bean id="sub" class="com.bean.attribute.world" p:string="subworld"></bean>
      <bean id="helloworld" class="com.bean.attribute.helloworld">
          <!-- 基本数据类型String,Integer,double...可以单独用value标签表示出来 -->
          <constructor-arg>
              <value>helloworld</value>
          </constructor-arg>
          <!-- 特殊字符需要输出时用单独的value标签,并使用<![CDATA[*****]]>包裹 -->
          <constructor-arg>
              <value><![CDATA[<<<特殊字符>>>]]></value>
          </constructor-arg>
          <constructor-arg value="20191202" type="Integer"></constructor-arg>
          <!-- ref代表该xml中bean对象的id名称 -->
          <constructor-arg ref="sub"></constructor-arg>
      </bean>
      ```
---
### 自动装配bean
  + 通过bean中的属性autowire实现
    > 一个bean只能指定一种autowire的方式，不能混用
    + byName
      > • spring 会自动在类中找到成员变量的setter方法(例如:public void setCar(Car car){})setCar,并获得set后的<b>小写！！</b>字符串作为匹配名称在对应的IOC容器xml文件中寻找bean.id名称<b>唯一！！</b>匹配的bean，实例化该bean作为参数传递给setter函数，然后再实例化执行自动装配autowire的bean。<br>
      > • 如果没有匹配到则返回null<br>
      > • 如果匹配到多个，则报错
    + byType
      > • 
      > spring
