### JVM虚拟机运行时数据区
  + ![java-1](https://github.com/flysafely/JAVA/blob/master/Pictures/F36B0C3C-D31B-4BFD-AE1E-E814E4CF03A4.jpeg)

  + ![java-2](https://github.com/flysafely/JAVA/blob/master/Pictures/84FEB020-7D43-4452-BE0A-DCFF9E389F62.jpeg)
  
### 程序计数器（Program Counter Register）
  > 1).程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。<br>
    2).**字节码解释器**通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>
    3).字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。<br>
    4).每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
      > 如上图所示，我们称这类内存区域为 : 线程私有内存。
    5).如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；<br>
    6).如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）<br>
    7).此内存区域是唯一一个在 Java 虚拟机中没有规范任何 OutOfMemoryError 情况的区域。
---
### Java 虚拟机栈
  ![java-3](https://github.com/flysafely/JAVA/blob/master/Pictures/6037FAE9-79AD-4883-9C8A-019872BFA7ED.png)
  
  * 1).Java 虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）
  * 2).StackOverflowError异常
    > JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此**虚拟机栈能够容纳的栈帧数量**是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用
  * 3).OutOfMemoryError异常；
    > 指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常
  * 4).Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法执行的同时会创建一个栈帧。stack 栈内存，就是虚拟机栈中局部变量表部分。
  
  + **局部变量表**
    * 局部变量表(Local Variable Table)是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。
    * 在Java程序编译为class文件时，就在方法的Code属性的max_locals数据项中确定了 该方法所需要分配的**局部变量表的最大容量**。
    * 最小单位为变量槽(Slot),一个Slot可以存放一个32位以内的数据类型,包括基本数据类型 (boolean、byte、char、short、int、float、long、double)「String 是引用类型」，对象引用 (reference 类型) 和 returnAddress 类型（它指向了一条字节码指令的地址）。
---
### 本地方法栈
  > 本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

  + **本地方法(Navtive方法)** 是Java通过JNI直接调用本地 C/C++ 库，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。
    > 当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。

  + 本地方法栈是一个**后入先出（Last In First Out）栈**。
  + 由于是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。
  + 本地方法栈同虚拟机栈一样会抛出 StackOverflowError 和 OutOfMemoryError 异常。
---
### 方法区
  + 保存在着被加载过的每一个类的信息；
    > 这些信息由类加载器在加载类的时候，从类的源文件中抽取出来；static变量信息也保存在方法区中；
  ![java-4](https://github.com/flysafely/JAVA/blob/master/Pictures/7F80E626-C259-44A3-9BAC-CA93362295CC.png)
  + 特点
    * 方法区是线程共享的
      > 当有多个线程都用到一个类的时候，而这个类还未被加载，则应该只有一个线程去加载类，让其他线程等待
    * 方法区的大小不必是固定的
      > jvm可以根据应用的需要动态调整。jvm也可以允许用户和程序指定方法区的初始大小，最小和最大限制
    * 方法区同样存在垃圾收集
      > 通过用户定义的类加载器可以动态扩展Java程序，这样可能会导致一些类，不再被使用，变为垃圾。这时候需要进行垃圾清理
  + **常量池**(jdk1.6后存放在堆heap中)
    > 在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；<br>
      在JDK6.0（1.6）之后版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。
    * (一)全局字符串常量池
      > 1).每当代码创建字符串常量时，JVM会首先检查字符串常量池。<br>
        2).如果字符串已经存在池中，就返回池中的实例引用。<br>
        3).如果字符串不在池中，就会实例化一个字符串并放到池中。<br>
        4).Java能够进行这样的优化是因为字符串是不可变的，不产生数据冲突进行共享。
    * (二)class常量池
      > class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 
      * 字面量
        > 就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 
      * 符号引用
        > 是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）
        * 一般包括下面三类常量：<br>
          1.类和接口的全限定名<br>
          2.字段的名称和描述符<br>
          3.方法的名称和描述符<br>
    * (三)运行时常量池
      > jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。<br>
      类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。<br>
      class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。<br>
      经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。
    * tips:
      * [Java中String对象在堆和常量池中的情况](https://blog.csdn.net/qq_40563761/article/details/83031715)
