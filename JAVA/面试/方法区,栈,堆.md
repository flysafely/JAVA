### JVM虚拟机运行时数据区
  + ![java-1](https://github.com/flysafely/JAVA/blob/master/Pictures/F36B0C3C-D31B-4BFD-AE1E-E814E4CF03A4.jpeg)

  + ![java-2](https://github.com/flysafely/JAVA/blob/master/Pictures/84FEB020-7D43-4452-BE0A-DCFF9E389F62.jpeg)
  
### 程序计数器（Program Counter Register）
  > 1).程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。<br>
    2).**字节码解释器**通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>
    3).字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。<br>
    4).每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
      > 如上图所示，我们称这类内存区域为 : 线程私有内存。
    5).如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；<br>
    6).如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）<br>
    7).此内存区域是唯一一个在 Java 虚拟机中没有规范任何 OutOfMemoryError 情况的区域。
---
### Java 虚拟机栈
  ![java-3](https://github.com/flysafely/JAVA/blob/master/Pictures/EA815AFF-E38C-4EE1-A466-7C9E879F645B.png)
  
  * 1).Java 虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）
  * 2).StackOverflowError异常
    > JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此**虚拟机栈能够容纳的栈帧数量**是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用
  * 3).OutOfMemoryError异常；
    > 指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常
  * 4).Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法执行的同时会创建一个栈帧。stack 栈内存，就是虚拟机栈中局部变量表部分。
  
  + **局部变量表**
    * 局部变量表(Local Variable Table)是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。
    * 在Java程序编译为class文件时，就在方法的Code属性的max_locals数据项中确定了 该方法所需要分配的**局部变量表的最大容量**。
    * 最小单位为变量槽(Slot),一个Slot可以存放一个32位以内的数据类型,包括基本数据类型 (boolean、byte、char、short、int、float、long、double)「String 是引用类型」，对象引用 (reference 类型) 和 returnAddress 类型（它指向了一条字节码指令的地址）。
---
### 本地方法栈
  > 本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

  + **本地方法(Navtive方法)** 是Java通过JNI直接调用本地 C/C++ 库，可以认为是 Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。
    > 当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。

  + 本地方法栈是一个**后入先出（Last In First Out）栈**。
  + 由于是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。
  + 本地方法栈同虚拟机栈一样会抛出 StackOverflowError 和 OutOfMemoryError 异常。
---
### 方法区
  + 类的版本
  + 字段
  + 方法
  + 接口
  + *常量池*
    > 在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；<br>
      在JDK6.0（1.6）之后版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。
  +
  +
