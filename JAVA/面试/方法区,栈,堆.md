### JVM虚拟机运行时数据区
  + ![java-1](https://github.com/flysafely/JAVA/blob/master/Pictures/F36B0C3C-D31B-4BFD-AE1E-E814E4CF03A4.jpeg)

  + ![java-2](https://github.com/flysafely/JAVA/blob/master/Pictures/84FEB020-7D43-4452-BE0A-DCFF9E389F62.jpeg)
  
### 程序计数器（Program Counter Register）
  > 1).程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。<br>
    2).**字节码解释器**通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>
    3).字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。<br>
    4).每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
      > 如上图所示，我们称这类内存区域为 : 线程私有内存。
    5).如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；<br>
    6).如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）<br>
    7).此内存区域是唯一一个在 Java 虚拟机中没有规范任何 OutOfMemoryError 情况的区域。
### Java 虚拟机栈
  ![java-3](https://github.com/flysafely/JAVA/blob/master/Pictures/EA815AFF-E38C-4EE1-A466-7C9E879F645B.png)
  * 1).Java 虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）
  * 2).StackOverflowError异常
    > JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此**虚拟机栈能够容纳的栈帧数量**是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用
  * 3).如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；
      > 当前大部分 JVM 都可以动态扩展，只不过 JVM 规范也允许固定长度的虚拟机栈
  * 4).Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法执行的同时会创建一个栈帧。stack 栈内存，就是虚拟机栈中局部变量表部分。
  
  + **局部变量表**
    * 局部变量表(Local Variable Table)是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。
    * 在Java程序编译为class文件时，就在方法的Code属性的max_locals数据项中确定了 该方法所需要分配的**局部变量表的最大容量**。
    * 最小单位为变量槽(Slot),一个Slot可以存放一个32位以内的数据类型,包括基本数据类型 (boolean、byte、char、short、int、float、long、double)「String 是引用类型」，对象引用 (reference 类型) 和 returnAddress 类型（它指向了一条字节码指令的地址）。
